# 笔记

## 运维笔记

### 一、Linux 常用命令

####  tar

```shell
tar -xzvf apache-tomcat.tar.gz -C jieya/
```



#### zip

压缩

```shell
zip -r -9 wenjian.zip /opt/wenjian
```



解压

```shell
unzip wenjian.zip -d /opt/wenjian
```



更多请使用man命令



####  lsblk 

> 用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘，闪存盘，cd-ROM等等。lsblk命令包含在util-linux-ng包中，现在该包改名为util-linux。这个包带了几个其它工具，如dmesg。Fedora用户可以通过命令sudo yum install util-linux-ng来安装该包。

选项

```shell
-a, --all            显示所有设备。
-b, --bytes          以bytes方式显示设备大小。
-d, --nodeps         不显示 slaves 或 holders。
-D, --discard        print discard capabilities。
-e, --exclude <list> 排除设备 (default: RAM disks)。
-f, --fs             显示文件系统信息。
-h, --help           显示帮助信息。
-i, --ascii          use ascii characters only。
-m, --perms          显示权限信息。
-l, --list           使用列表格式显示。
-n, --noheadings     不显示标题。
-o, --output <list>  输出列。
-P, --pairs          使用key="value"格式显示。
-r, --raw            使用原始格式显示。
-t, --topology       显示拓扑结构信息。
```

实例

lsblk命令默认情况下将以树状列出所有块设备。打开终端，并输入以下命令：

```shell
lsblk

NAME   MAJ:MIN rm   SIZE RO type mountpoint
sda      8:0    0 232.9G  0 disk 
├─sda1   8:1    0  46.6G  0 part /
├─sda2   8:2    0     1K  0 part 
├─sda5   8:5    0   190M  0 part /boot
├─sda6   8:6    0   3.7G  0 part [SWAP]
├─sda7   8:7    0  93.1G  0 part /data
└─sda8   8:8    0  89.2G  0 part /personal
sr0     11:0    1  1024M  0 rom
```

1. **NAME** ：这是块设备名。
2. **MAJ:MIN** ：本栏显示主要和次要设备号。
3. **RM** ：本栏显示设备是否可移动设备。注意，在本例中设备sdb和sr0的RM值等于1，这说明他们是可移动设备。
4. **SIZE** ：本栏列出设备的容量大小信息。例如298.1G表明该设备大小为298.1GB，而1K表明该设备大小为1KB。
5. **RO** ：该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。
6. **TYPE** ：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。
7. **MOUNTPOINT** ：本栏指出设备挂载的挂载点。

默认选项不会列出所有空设备。要查看这些空设备，请使用以下命令：

```shell
lsblk -a
```

lsblk命令也可以用于列出一个特定设备的拥有关系，同时也可以列出组和模式。可以通过以下命令来获取这些信息：

```shell
lsblk -m
```

该命令也可以只获取指定设备的信息。这可以通过在提供给lsblk命令的选项后指定设备名来实现。例如，你可能对了解以字节显示你的磁盘驱动器大小比较感兴趣，那么你可以通过运行以下命令来实现：

```shell
lsblk -b /dev/sda

等价于

lsblk --bytes /dev/sda
```



你也可以组合几个选项来获取指定的输出。例如，你也许想要以列表格式列出设备，而不是默认的树状格式。你可能也对移除不同栏目名称的标题感兴趣。可以将两个不同的选项组合，以获得期望的输出，命令如下：



```shell
lsblk -nl
```

要获取SCSI设备的列表，你只能使用-S选项。该选项是大写字母S，不能和-s选项混淆，该选项是用来以颠倒的顺序打印依赖的。

```shell
lsblk -S
```

lsblk列出SCSI设备，而-s是逆序选项（将设备和分区的组织关系逆转过来显示），其将给出如下输出。输入命令：

```shell
lsblk -s
```





#### fdisk 

是Linux下常用的磁盘分区工具 在低版本linux中 受mbr分区表的限制，fdisk工具只能给小于2TB的磁盘划分分区。如果使用fdisk对大于2TB的磁盘进行分区，虽然可以分区，但其仅识别2TB的空间。在高版本中可先创建分区表gpt，可得到一个独立的分区uuid。

下面演示大硬盘挂载指 大于2个T的硬盘

```shell
[root@7-64-test ~]# fdisk -l					//查询磁盘情况

Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000c145a

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048      616447      307200   83  Linux
/dev/sda2          616448    41943039    20663296   8e  Linux LVM

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors		//新增加的空白磁盘
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/centos-root: 17.9 GB, 17930649600 bytes, 35020800 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/centos-swap: 3221 MB, 3221225472 bytes, 6291456 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@7-64-test ~]# fdisk -l /dev/sdb			//查看新增的磁盘								

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@7-64-test ~]# fdisk  /dev/sdb				//进行分区
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x1bdd0658.

Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x1bdd0658

   Device Boot      Start         End      Blocks   Id  System

Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)

Command (m for help): g					//创建gpt磁盘
Building a new GPT disklabel (GUID: 26965E7C-1CD5-4EB3-B1F4-DE7E5B896224)


Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: gpt
Disk identifier: 26965E7C-1CD5-4EB3-B1F4-DE7E5B896224


#         Start          End    Size  Type            Name

Command (m for help): n						//新建分区
Partition number (1-128, default 1): 
First sector (2048-2097118, default 2048): 
Last sector, +sectors or +size{K,M,G,T,P} (2048-2097118, default 2097118): +100M
Created partition 1


Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: gpt
Disk identifier: 26965E7C-1CD5-4EB3-B1F4-DE7E5B896224


#         Start          End    Size  Type            Name

 1         2048       206847    100M  Linux filesyste 

Command (m for help): w						//保存退出
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.


```

需要注意的是一般来说都说使用一下工具来查看主机硬盘关系

```shell
[root@databases ~]# lsblk #查看硬盘关系
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0   80G  0 disk 
├─sda1          8:1    0    1G  0 part /boot
└─sda2          8:2    0   79G  0 part 
  ├─rhel-root 253:0    0   50G  0 lvm  /
  ├─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
  └─rhel-home 253:2    0   27G  0 lvm  /home
sr0            11:0    1 55.3M  0 rom  
loop0           7:0    0  4.3G  0 loop /mnt/rhel-server-7.5-x86_64-dvd
#使用/dev/sda  /dev/sda1 来访问这些磁盘
```

```shell
[root@databases ~]# blkid #使用blkid来查询uuid是多少 多用于 /etc/fstab 的编写
/dev/sda1: UUID="8b47b73b-e878-456c-844f-d3137258cc9d" TYPE="xfs" 
/dev/sda2: UUID="hwFuqI-bcS0-M0xs-pRoB-Iwet-y747-eFCKh0" TYPE="LVM2_member" 
/dev/sr0: UUID="2018-11-08-19-58-33-33" LABEL="VBox_GAs_5.2.22" TYPE="iso9660" 
/dev/mapper/rhel-root: UUID="de1d8b6b-de6a-48c0-a60b-5f57b9aa87b1" TYPE="xfs" 
/dev/mapper/rhel-swap: UUID="e7676ccc-8a5a-4a15-9d65-9213833ddeac" TYPE="swap" 
/dev/mapper/rhel-home: UUID="a8b1af4f-d8f5-4b58-8c64-62215e91302e" TYPE="xfs" 
/dev/loop0: UUID="2018-03-22-19-04-59-00" LABEL="RHEL-7.5 Server.x86_64" TYPE="iso9660" PTTYPE="dos" 
```

#### mount umount 

常见的挂载

```shell
mount -t iso9660 -o,loop /media/CentOS-7-x86_64-DVD-1804.iso /mnt/Centos7 #挂载硬盘

mount -t ntfs /dev/mmcblk0p1 /mnt/xiaojian #挂载ntfs共享盘

mount /dev/sdb4 guazai #对于fat32格式的u盘或驱动器 

mount 设备 路径 #常见的挂载方式

umount 路径 #取消挂载

```

#### fuser 

使用文件或文件结构识别进程  一般可以用来识别磁盘正在忙碌进程。

补充说明

fuser命令 用于报告进程使用的文件和网络套接字。fuser命令列出了本地进程的进程号，那些本地进程使用file，参数指定的本地或远程文件。对于阻塞特别设备，此命令列出了使用该设备上任何文件的进程。

每个进程号后面都跟随一个字母，该字母指示进程如何使用文件。

- c：指示进程的工作目录。
- e：指示该文件为进程的可执行文件(即进程由该文件拉起)。
- f：指示该文件被进程打开，默认情况下f字符不显示。
- F：指示该文件被进程打开进行写入，默认情况下F字符不显示。
- r：指示该目录为进程的根目录。
- m：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。

安装

```shell
[root@bogon ~]# yum install -y psmisc
```



```shell
[root@bogon ~]# fuser --help
fuser: Invalid option --help
Usage: fuser [-fMuvw] [-a|-s] [-4|-6] [-c|-m|-n SPACE] [-k [-i] [-SIGNAL]] NAME...
       fuser -l
       fuser -V
Show which processes use the named files, sockets, or filesystems.

  -a,--all              display unused files too
  -i,--interactive      ask before killing (ignored without -k)
  -k,--kill             kill processes accessing the named file
  -l,--list-signals     list available signal names
  -m,--mount            show all processes using the named filesystems or block device
  -M,--ismountpoint     fulfill request only if NAME is a mount point
  -n,--namespace SPACE  search in this name space (file, udp, or tcp)
  -s,--silent           silent operation
  -SIGNAL               send this signal instead of SIGKILL
  -u,--user             display user IDs
  -v,--verbose          verbose output
  -w,--writeonly        kill only processes with write access
  -V,--version          display version information
  -4,--ipv4             search IPv4 sockets only
  -6,--ipv6             search IPv6 sockets only
  -                     reset options

  udp/tcp names: [local_port][,[rmt_host][,[rmt_port]]]

```



中文译文



```shell
-a：显示命令行中指定的所有文件；
-k：杀死访问指定文件的所有进程；
-i：杀死进程前需要用户进行确认；
-l：列出所有已知信号名；
-m：指定一个被加载的文件系统或一个被加载的块设备；
-n：选择不同的名称空间；
-u：在每个进程后显示所属的用户名。
```



常用实例：

要列出使用`/etc/passwd`文件的本地进程的进程号，请输入：

```shell
fuser /etc/passwd
```

要列出使用`/etc/filesystems`文件的进程的进程号和用户登录名，请输入：

```shell
fuser -u /etc/filesystems
```

要终止使用给定文件系统的所有进程，请输入：

```shell
fuser -k -x -u -c /dev/hd1  或者  fuser -kxuc /home
```

要列出正在占用分区的分区:

```shell
fuser -m -v /dev/sdb1

```



#### chmod、chown权限

```shell
chown -R 用户名:用户所在的组 文件或目录

chmod -R ugo=rwx 文件或目录

# ugo 表示为 用户 组  其他用户

chmod ug=wrx,o=wrx xiaojian.zip
```



#### rpm 

```shell
Rpm -ivh 安装包文件

Rpm -qa 查看所有安装包

Rpm -ql 产看安装路径
```



#### Systemctl

查询安装的服务

```shell
Systemctl list-unit-files | grep nginx
```



#### init

Init(谨慎使用)(突发情况)

 

Init6 杀死所有程序立即关机（等于强行关机）

​        0 - 停机（千万不能把initdefault 设置为0 ）

　　1 - 单用户模式

　     2 - 多用户，没有 NFS

　　 3 - 完全多用户模式(标准的运行级)

　　 4 - 没有用到

　　  5 - X11 （xwindow)

​          6 - 重新启动 （千万不要把initdefault 设置为6 ）



#### make

make clean与make distclean的区别

make clean仅仅是清除之前编译的可执行文件及配置文件。

而make distclean要清除所有生成的文件。

 

Makefile

 

在符合GNU Makefiel惯例的Makefile中，包含了一些基本的预先定义的操作：

 

make

 

根据Makefile编译源代码，连接，生成目标文件，可执行文件。

 

make clean

 

清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。

 

make install

 

将编译成功的可执行文件安装到系统目录中，一般为/usr/local/bin目录。

 

make dist

 

产生发布软件包文件（即distribution package）。这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。

 

它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件。PACKAGE和VERSION，是我们在configure.in中定义的AM_INIT_AUTOMAKE(PACKAGE, VERSION)。

 

make distcheck

 

生成发布软件包并对其进行测试检查，以确定发布包的正确性。这个操作将自动把压缩包文件解开，然后执行configure命令，并且执行make，来确认编译不出现错误，最后提示你软件包已经准备好，可以发布了。

 

make distclean类似make clean，但同时也将configure生成的文件全部删除掉，包括Makefile。



### 二、常用工具

#### 1. yum工具 设置

##### 1. yum 本地源设置

```shell
#本地iso做好挂载并映射
[root@k8smaster01 yum.repos.d]# cat CentOS-Base.repo
[bendi] 
name=bendi
baseurl=file:///mnt/Centos7
gpgcheck=1
gpgkey=file:///mnt//Centos7/RPM-GPG-KEY-CentOS-7

#清理yum 缓存
[root@k8smaster01 yum.repos.d]# yum clean all

#生成yum 缓存
[root@k8smaster01 yum.repos.d]# yum makecache

#检查yum源是否正常
[root@k8smaster01 yum.repos.d]#  yum repolist

```

##### 2.yum 网络本地源设置

```shell
#本地iso做好挂载并映射
[root@k8smaster01 yum.repos.d]# cat CentOS-Base.repo
[local_docker]
name=loacl docker
#区别在这
baseurl=http://192.168.1.7/rpm_package/
gpgcheck=1
enabled=1
gpgkey=http://192.168.1.7/rpm_package/RPM-GPG-KEY-redhat-release

#清理yum 缓存
[root@k8smaster01 yum.repos.d]# yum clean all

#生成yum 缓存
[root@k8smaster01 yum.repos.d]# yum makecache

#检查yum源是否正常
[root@k8smaster01 yum.repos.d]#  yum repolist

```

##### 3.创建私有yum源和下载源资源

```shell
#先安装createrepo工具
[root@k8smaster01 yum.repos.d]# yum -y install createrepo -y

#使用createrepo 生成缓存列表文件
#其中rpm包在/root/RPM路径下
#后面一定要跟绝对路径 -o 后面是输出的地址 ,最后一个参数是rpm包下面
[root@k8smaster01 yum.repos.d]# createrepo -o /root/RPM -v /

#当需要更新rpm包时，使用update参数，需要注意的是需要切换到repodata上级目录

[root@k8smaster01 yum.repos.d]# createrepo --update ./Packages/

```



下载源的资源

先在一台可以联网并且版本和目标主机相似的服务器上下载软件源：
先安装下载软件源所需工具：



```
yum install yum-utils -y
```

之后用命令查看软件源列表：

```shell
yum repolist
repo id                   repo name                                       status
base/7/x86_64            CentOS-7 - Base - mirrors.aliyun.com            9,911
extras/7/x86_64          CentOS-7 - Extras - mirrors.aliyun.com            313
updates/7/x86_64         CentOS-7 - Updates - mirrors.aliyun.com           695

```



一般来说只用下载base库就够了，运行命令：

```
reposync -r base
```

base库的所有软件包就会下载到当前目录，目录结构一般像这样

```
–base
|—03d0a660e33174331aee3e077e11d4c0412d761b7f2eaa8555e7898e701e0-primary.sqlite.bz2
|—29b154c359eaf129e35d0d5c649ebd6ce333f302f33ed7b08c3b927e20-c7-x86_64-comps.xml.gz
|—cachecooki
|—gen
|—Packages
|—repomd.xml
```

我们需要用到的软件包就在Packages目录下面，只需把Packages目录打包发到目标主机上就可以了



##### 4. 其他

```shell
#查看已安装软件包
[root@k8smaster01 yum.repos.d]# yum list installed 
[root@k8smaster01 yum.repos.d]# rpm -qa 

#只选择从一个yum源安装
[root@k8smaster01 yum.repos.d] yum install XXX --enablerepo=YYY

#如果是redhat 需要关闭redhat 订阅功能
[root@k8smaster01 yum.repos.d] vi /etc/yum/pluginconf.d/subscription-manager.conf
[main]
enabled=0

#查看不同版本的安装包

yum search all 软件包 --showduplicates
# Doesn't limit packages to their latest versions in the info, list and search commands (will also affect plugins which use the doPackageLists() API).




```





##### 5. yum\下载离线包

有时会遇到安装linux软件时处理许许多多的依赖，很麻烦，那么这个工具可能会帮到你。

1. 首先在外网搭建一台纯净的linux系统
2. 安装yum-utils工具
3. 配置好你需要的yum源、例如docker、k8s、google等等
4. 执行只下载不安装命令下载所有的包至一个文件夹下，打包到内网进行安装。

   

安装yum-utils工具

```shell
[root@bogon mypackages]# yum install yum-utils
```



注：例如下载google的安装包

先配置google下载的yum源

```shell

vim /etc/yum.repos.d/google-chrome.repo
 
[google-chrome]
name=google-chrome
baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch
enabled=1
gpgcheck=1
gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub

```

```shell
yum clean all
yum makecache
```



```shell
#destdir目标地址  google-chrome-stable 谷歌安装包
#--resolve 解析依赖关系并下载所需的包
yumdownloader --resolve --destdir /root/mypackages/ google-chrome-stable

yumdownloader --help

#功能和yumdownloader一样
 yum install --downloadonly --downloaddir=/root/




```









#### 2. Lvm 扩盘简单步骤 

基本环境

一台2c、2g、两块30硬盘、其中一块30g已被系统默认做成了lvm系统盘、另一个是裸盘。



##### 1. 创建pv

查看环境，找到裸盘或分区

```shell
[root@bogon ~]# lsblk
NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                     8:0    0   30G  0 disk 
├─sda1                  8:1    0    1G  0 part /boot
└─sda2                  8:2    0   29G  0 part 
  ├─centos_bogon-root 253:0    0   27G  0 lvm  /
  └─centos_bogon-swap 253:1    0    2G  0 lvm  [SWAP]
sdb                     8:16   0   30G  0 disk 
sr0                    11:0    1 1024M  0 rom  

```

查看pv

```sehll
[root@bogon ~]# pvdisplay 
  --- Physical volume ---
  PV Name               /dev/sda2
  VG Name               centos_bogon
  PV Size               <29.00 GiB / not usable 3.00 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              7423
  Free PE               1
  Allocated PE          7422
  PV UUID               4LapEC-4R0M-Uf0c-dxEL-l7SX-my8y-hXjWVp
    
[root@bogon ~]# pvs
  PV         VG           Fmt  Attr PSize   PFree
  /dev/sda2  centos_bogon lvm2 a--  <29.00g 4.00m

```

创建pv

```shell
[root@bogon ~]# lsblk
NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                     8:0    0   30G  0 disk 
├─sda1                  8:1    0    1G  0 part /boot
└─sda2                  8:2    0   29G  0 part 
  ├─centos_bogon-root 253:0    0   27G  0 lvm  /
  └─centos_bogon-swap 253:1    0    2G  0 lvm  [SWAP]
sdb                     8:16   0   30G  0 disk 
sr0                    11:0    1 1024M  0 rom  
[root@bogon ~]# pvcreate /dev/sdb
  Physical volume "/dev/sdb" successfully created.
[root@bogon ~]# pvdisplay 
  --- Physical volume ---
  PV Name               /dev/sda2
  VG Name               centos_bogon
  PV Size               <29.00 GiB / not usable 3.00 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              7423
  Free PE               1
  Allocated PE          7422
  PV UUID               4LapEC-4R0M-Uf0c-dxEL-l7SX-my8y-hXjWVp
   
  "/dev/sdb" is a new physical volume of "30.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb
  VG Name               
  PV Size               30.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               qHFeRh-LvTe-mcZ6-zwj6-0nHT-usQg-REz48B

```



##### 2. 创建或加入vg容器

查看 vg容器信息

```shell
[root@bogon ~]# pvdisplay 
  --- Physical volume ---
  PV Name               /dev/sda2
  VG Name               centos_bogon
  PV Size               <29.00 GiB / not usable 3.00 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              7423
  Free PE               1
  Allocated PE          7422
  PV UUID               4LapEC-4R0M-Uf0c-dxEL-l7SX-my8y-hXjWVp
   
  "/dev/sdb" is a new physical volume of "30.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb
  VG Name               
  PV Size               30.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               qHFeRh-LvTe-mcZ6-zwj6-0nHT-usQg-REz48B
   
[root@bogon ~]# vgdisplay 
  --- Volume group ---
  VG Name               centos_bogon
  System ID             
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  3
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               2
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               <29.00 GiB
  PE Size               4.00 MiB
  Total PE              7423
  Alloc PE / Size       7422 / 28.99 GiB
  Free  PE / Size       1 / 4.00 MiB
  VG UUID               5jGw3j-OcDg-GZJB-7LFF-H3r3-Lh94-aITZwY
   
[root@bogon ~]# vgs
  VG           #PV #LV #SN Attr   VSize   VFree
  centos_bogon   1   2   0 wz--n- <29.00g 4.00m

```

创建 vg或拓展vg

```shell
#创建vg
[root@bogon ~]# vgcreate vgname /dev/sdb 

```

因为这里我们的目的是要扩展目标分区 所以应该选择拓展vg



```shell
[root@bogon ~]# vgs
  VG           #PV #LV #SN Attr   VSize   VFree
  centos_bogon   1   2   0 wz--n- <29.00g 4.00m
[root@bogon ~]# vgextend centos_bogon /dev/sdb 
  Volume group "centos_bogon" successfully extended
[root@bogon ~]# vgdisplay 
  --- Volume group ---
  VG Name               centos_bogon
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  4
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               2
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               58.99 GiB
  PE Size               4.00 MiB
  Total PE              15102
  Alloc PE / Size       7422 / 28.99 GiB
  Free  PE / Size       7680 / 30.00 GiB
  VG UUID               5jGw3j-OcDg-GZJB-7LFF-H3r3-Lh94-aITZwY

```

可以看到 centos_bogon容量变大了。



##### 3. 创建或拓展逻辑分区lv

```shell
[root@bogon ~]# lvs
  LV   VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  root centos_bogon -wi-ao---- 26.99g                                                    
  swap centos_bogon -wi-ao----  2.00g                                                    
[root@bogon ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/centos_bogon/swap
  LV Name                swap
  VG Name                centos_bogon
  LV UUID                sl0gcG-neOt-qnv3-q7QD-vIaT-YYLb-cCUc8U
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 2
  LV Size                2.00 GiB
  Current LE             512
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:1
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/root
  LV Name                root
  VG Name                centos_bogon
  LV UUID                93tfxD-2mIe-ZrDq-b9hb-ruH8-hg0V-tXU1OY
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 1
  LV Size                26.99 GiB
  Current LE             6910
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0

```



现在让我们创建一个小于5g的小分区，并拓展/dev/centos_bogon/root此分区

```shell
[root@bogon ~]# lvcreate -n ceshi -L 5G centos_bogon  
  Logical volume "ceshi" created.
[root@bogon ~]# lvs
  LV    VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  ceshi centos_bogon -wi-a-----  5.00g                                                    
  root  centos_bogon -wi-ao---- 26.99g                                                    
  swap  centos_bogon -wi-ao----  2.00g                                                    

```

可以看见 ceshi已经被创建，接下来然我们格式化它并挂载到文件目录下。

```shell
[root@bogon ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/centos_bogon/swap
  LV Name                swap
  VG Name                centos_bogon
  LV UUID                sl0gcG-neOt-qnv3-q7QD-vIaT-YYLb-cCUc8U
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 2
  LV Size                2.00 GiB
  Current LE             512
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:1
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/root
  LV Name                root
  VG Name                centos_bogon
  LV UUID                93tfxD-2mIe-ZrDq-b9hb-ruH8-hg0V-tXU1OY
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 1
  LV Size                26.99 GiB
  Current LE             6910
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/ceshi
  LV Name                ceshi
  VG Name                centos_bogon
  LV UUID                kOsUcA-Z7K3-uacd-fhxr-BNLc-KXpl-LRvBVp
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 13:23:14 +0800
  LV Status              available
  # open                 0
  LV Size                5.00 GiB
  Current LE             1280
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2

```



```shell
[root@bogon ~]# ls /dev/centos_bogon/ceshi
/dev/centos_bogon/ceshi
[root@bogon ~]# mkfs.ext4 /dev/centos_bogon/ceshi 
mke2fs 1.42.9 (28-Dec-2013)
文件系统标签=
OS type: Linux
块大小=4096 (log=2)
分块大小=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
327680 inodes, 1310720 blocks
65536 blocks (5.00%) reserved for the super user
第一个数据块=0
Maximum filesystem blocks=1342177280
40 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736

Allocating group tables: 完成                            
正在写入inode表: 完成                            
Creating journal (32768 blocks): 完成
Writing superblocks and filesystem accounting information: 完成 

```

查看磁盘并加入到自动挂载/etc/fstab 里面 

```shell
[root@bogon ~]# blkid
/dev/sda1: UUID="286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80" TYPE="xfs" 
/dev/sda2: UUID="4LapEC-4R0M-Uf0c-dxEL-l7SX-my8y-hXjWVp" TYPE="LVM2_member" 
/dev/sdb: UUID="qHFeRh-LvTe-mcZ6-zwj6-0nHT-usQg-REz48B" TYPE="LVM2_member" 
/dev/mapper/centos_bogon-root: UUID="18992acd-5d01-4416-b371-f8034b81a88e" TYPE="xfs" 
/dev/mapper/centos_bogon-swap: UUID="04721e03-2370-40f4-a5c9-3f41e7b09709" TYPE="swap" 
/dev/mapper/centos_bogon-ceshi: UUID="4006bb67-a97f-4648-8224-3a45a0a694a8" TYPE="ext4" 
[root@bogon ~]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Fri Nov 20 10:54:05 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos_bogon-root /                       xfs     defaults        0 0
UUID=286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80 /boot                   xfs     defaults        0 0
/dev/mapper/centos_bogon-swap swap                    swap    defaults        0 0
[root@bogon ~]# fdisk -l /dev/mapper/centos_bogon-ceshi

磁盘 /dev/mapper/centos_bogon-ceshi：5368 MB, 5368709120 字节，10485760 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节


```



我在这里注意到所有在fdisk 列出的项中没有 /dev/centos_bogon/ceshi 这是因为  /dev/centos_bogon/ceshi的链接和 /dev/mapper/centos_bogon-ceshi指向的是同一个设备.见下图:



```shell
[root@bogon ~]# ll /dev/centos_bogon/
总用量 0
lrwxrwxrwx. 1 root root 7 11月 20 13:47 ceshi -> ../dm-2
lrwxrwxrwx. 1 root root 7 11月 20 11:21 root -> ../dm-0
lrwxrwxrwx. 1 root root 7 11月 20 11:21 swap -> ../dm-1
[root@bogon ~]# ll /dev/mapper/
总用量 0
lrwxrwxrwx. 1 root root       7 11月 20 13:47 centos_bogon-ceshi -> ../dm-2
lrwxrwxrwx. 1 root root       7 11月 20 11:21 centos_bogon-root -> ../dm-0
lrwxrwxrwx. 1 root root       7 11月 20 11:21 centos_bogon-swap -> ../dm-1
crw-------. 1 root root 10, 236 11月 20 11:21 control

```

所以应当使用 lvm统一管理的目录/dev/mapper/ 下来进行挂载

```shell
[root@bogon dev]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Fri Nov 20 10:54:05 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos_bogon-root /                       xfs     defaults        0 0
UUID=286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80 /boot                   xfs     defaults        0 0
/dev/mapper/centos_bogon-swap swap                    swap    defaults        0 0
/dev/mapper/centos_bogon-ceshi    /ceshi              ext4    defaults        0 0
          
[root@bogon dev]# mount -a
[root@bogon dev]# df -TH
文件系统                       类型      容量  已用  可用 已用% 挂载点
/dev/mapper/centos_bogon-root  xfs        29G  1.2G   28G    4% /
devtmpfs                       devtmpfs  952M     0  952M    0% /dev
tmpfs                          tmpfs     964M     0  964M    0% /dev/shm
tmpfs                          tmpfs     964M  8.9M  955M    1% /run
tmpfs                          tmpfs     964M     0  964M    0% /sys/fs/cgroup
/dev/sda1                      xfs       1.1G  152M  912M   15% /boot
tmpfs                          tmpfs     193M     0  193M    0% /run/user/0
/dev/mapper/centos_bogon-ceshi ext4      5.2G   21M  4.9G    1% /ceshi

```

刚刚我们演示了如何新增一个分区，接下来我们演示如何为一个分区扩容。

```shell
[root@bogon dev]# vgdisplay 
  --- Volume group ---
  VG Name               centos_bogon
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  9
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                3
  Open LV               3
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               58.99 GiB
  PE Size               4.00 MiB
  Total PE              15102
  Alloc PE / Size       8702 / 33.99 GiB
  Free  PE / Size       6400 / 25.00 GiB
  VG UUID               5jGw3j-OcDg-GZJB-7LFF-H3r3-Lh94-aITZwY
   
[root@bogon dev]# vgs
  VG           #PV #LV #SN Attr   VSize  VFree 
  centos_bogon   2   3   0 wz--n- 58.99g 25.00g
[root@bogon dev]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/centos_bogon/swap
  LV Name                swap
  VG Name                centos_bogon
  LV UUID                sl0gcG-neOt-qnv3-q7QD-vIaT-YYLb-cCUc8U
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 2
  LV Size                2.00 GiB
  Current LE             512
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:1
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/root
  LV Name                root
  VG Name                centos_bogon
  LV UUID                93tfxD-2mIe-ZrDq-b9hb-ruH8-hg0V-tXU1OY
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 1
  LV Size                26.99 GiB
  Current LE             6910
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/ceshi
  LV Name                ceshi
  VG Name                centos_bogon
  LV UUID                4egzD2-akcf-qiDI-EDA1-UANL-QEc6-dY0TMZ
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 13:47:27 +0800
  LV Status              available
  # open                 1
  LV Size                5.00 GiB
  Current LE             1280
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2
   
[root@bogon dev]# lvs
  LV    VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  ceshi centos_bogon -wi-ao----  5.00g                                                    
  root  centos_bogon -wi-ao---- 26.99g                                                    
  swap  centos_bogon -wi-ao----  2.00g                         
```



从上图可得知，/dev/centos_bogon/ceshi 是隶属于VG centos_bogon的，而VG centos_bogon剩余25.00g ,vg的扩容我们之前已经讲过了，也就是说ceshi最多可以在扩容 25g ，现在我们开始干吧。

```shell
[root@bogon dev]# lvextend -L +24G /dev/centos_bogon/ceshi
  Size of logical volume centos_bogon/ceshi changed from 5.00 GiB (1280 extents) to 29.00 GiB (7424 extents).
  Logical volume centos_bogon/ceshi successfully resized.
[root@bogon dev]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/centos_bogon/swap
  LV Name                swap
  VG Name                centos_bogon
  LV UUID                sl0gcG-neOt-qnv3-q7QD-vIaT-YYLb-cCUc8U
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 2
  LV Size                2.00 GiB
  Current LE             512
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:1
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/root
  LV Name                root
  VG Name                centos_bogon
  LV UUID                93tfxD-2mIe-ZrDq-b9hb-ruH8-hg0V-tXU1OY
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 10:54:04 +0800
  LV Status              available
  # open                 1
  LV Size                26.99 GiB
  Current LE             6910
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
  --- Logical volume ---
  LV Path                /dev/centos_bogon/ceshi
  LV Name                ceshi
  VG Name                centos_bogon
  LV UUID                4egzD2-akcf-qiDI-EDA1-UANL-QEc6-dY0TMZ
  LV Write Access        read/write
  LV Creation host, time bogon, 2020-11-20 13:47:27 +0800
  LV Status              available
  # open                 1
  LV Size                29.00 GiB
  Current LE             7424
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2
   
[root@bogon dev]# lvs
  LV    VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  ceshi centos_bogon -wi-ao---- 29.00g                                                    
  root  centos_bogon -wi-ao---- 26.99g                                                    
  swap  centos_bogon -wi-ao----  2.00g                                                    

```

此时 ，ceshi逻辑lv分区已扩容到29g，但实际使用的分区尚未发生变化。我们需要手动刷新分区。

```shell
[root@bogon dev]# df -TH
文件系统                       类型      容量  已用  可用 已用% 挂载点
/dev/mapper/centos_bogon-root  xfs        29G  1.2G   28G    4% /
devtmpfs                       devtmpfs  952M     0  952M    0% /dev
tmpfs                          tmpfs     964M     0  964M    0% /dev/shm
tmpfs                          tmpfs     964M  8.9M  955M    1% /run
tmpfs                          tmpfs     964M     0  964M    0% /sys/fs/cgroup
/dev/sda1                      xfs       1.1G  152M  912M   15% /boot
tmpfs                          tmpfs     193M     0  193M    0% /run/user/0
/dev/mapper/centos_bogon-ceshi ext4      5.2G   21M  4.9G    1% /ceshi

[root@bogon dev]# resize2fs /dev/centos_bogon/ceshi
resize2fs 1.42.9 (28-Dec-2013)
Filesystem at /dev/centos_bogon/ceshi is mounted on /ceshi; on-line resizing required
old_desc_blocks = 1, new_desc_blocks = 4
The filesystem on /dev/centos_bogon/ceshi is now 7602176 blocks long.

[root@bogon dev]# df -TH
文件系统                       类型      容量  已用  可用 已用% 挂载点
/dev/mapper/centos_bogon-root  xfs        29G  1.2G   28G    4% /
devtmpfs                       devtmpfs  952M     0  952M    0% /dev
tmpfs                          tmpfs     964M     0  964M    0% /dev/shm
tmpfs                          tmpfs     964M  8.9M  955M    1% /run
tmpfs                          tmpfs     964M     0  964M    0% /sys/fs/cgroup
/dev/sda1                      xfs       1.1G  152M  912M   15% /boot
tmpfs                          tmpfs     193M     0  193M    0% /run/user/0
/dev/mapper/centos_bogon-ceshi ext4       31G   29M   30G    1% /ceshi

```

上面的步骤需要的是刷新分区命令有以下两种，不同的分区格式对应着不同的刷新命令。

从网上查到的资料上说：

> resize2fs 针对文件系统ext2 ext3 ext4
> xfs_growfs 针对文件系统xfs

```shell
[root@bogon dev]# resize2fs /dev/centos_bogon/ceshi
[root@bogon dev]# xfs_growfs /dev/centos_bogon/ceshi
```



##### 4. 更换物理硬盘

在某些极端情况下，物理磁盘损坏，需要更换物理磁盘，我们需要先计算退出的磁盘的大小，对磁盘所加入的vg来说，新加入的磁盘不能比老的磁盘小，除非vg的空闲容量大于老磁盘容量减去新磁盘容量。

在这个实验中，我们新增一块30g的硬盘，用这块硬盘替换上面的第二块硬盘。



```shell
[root@bogon ~]# lsblk 
NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                     8:0    0   30G  0 disk 
├─sda1                  8:1    0    1G  0 part /boot
└─sda2                  8:2    0   29G  0 part 
  ├─centos_bogon-root 253:0    0   27G  0 lvm  /
  └─centos_bogon-swap 253:1    0    2G  0 lvm  [SWAP]
sdb                     8:16   0   30G  0 disk 
└─centos_bogon-ceshi  253:2    0   29G  0 lvm  /ceshi
sdc                     8:32   0   30G  0 disk 
sr0                    11:0    1 1024M  0 rom  
[root@bogon ~]# pvs
  PV         VG           Fmt  Attr PSize   PFree   
  /dev/sda2  centos_bogon lvm2 a--  <29.00g    4.00m
  /dev/sdb   centos_bogon lvm2 a--  <30.00g 1020.00m
[root@bogon ~]# vgs
  VG           #PV #LV #SN Attr   VSize  VFree
  centos_bogon   2   3   0 wz--n- 58.99g 1.00g
[root@bogon ~]# vgdisplay 
  --- Volume group ---
  VG Name               centos_bogon
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  10
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                3
  Open LV               3
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               58.99 GiB
  PE Size               4.00 MiB
  Total PE              15102
  Alloc PE / Size       14846 / 57.99 GiB
  Free  PE / Size       256 / 1.00 GiB
  VG UUID               5jGw3j-OcDg-GZJB-7LFF-H3r3-Lh94-aITZwY

```



从上图可知，/dev/sdb 是挂载在vg centos_bogon 上面的。所以首先把新赠的磁盘新建pv 加入到vg centos_bogon

```shell

[root@bogon ~]# pvcreate /dev/sdc
  Physical volume "/dev/sdc" successfully created.
[root@bogon ~]# vgex
vgexport  vgextend  
[root@bogon ~]# vgex
vgexport  vgextend  
[root@bogon ~]# vgs
  VG           #PV #LV #SN Attr   VSize  VFree
  centos_bogon   2   3   0 wz--n- 58.99g 1.00g
[root@bogon ~]# vgextend centos_bogon /dev/sdc
  Volume group "centos_bogon" successfully extended
  
```



根据计算 加入的容量完全可以置换出/dev/sdb的内容，我们开始转移资料。

pvmove命令搬移PV中的资料(只限于同一VG中)。
pvmove命令相关的命令有：pvscan,pvchange,pvremove,pvdisplay.vgreduce

例子：

```shell
pvmove /dev/hda5 /dev/hda6　　　#将VG中pv hda5的内容搬移到hda6中

pvmove /dev/hda5　　　#也可以这样，lvm决定hda5的内容被复制到哪里
```



接下 我们搬移pv /dev/sdb 至/dev/sdc。

```shell
[root@bogon ceshi]# pvmove /dev/sdb /dev/sdc
  /dev/sdb: Moved: 0.11%
  /dev/sdb: Moved: 29.70%
  /dev/sdb: Moved: 59.51%
  /dev/sdb: Moved: 89.41%
  /dev/sdb: Moved: 100.00%
[root@bogon ceshi]# pvremove /dev/sdb #这里如果直接删除就会报错
  PV /dev/sdb is used by VG centos_bogon so please use vgreduce first.
  (If you are certain you need pvremove, then confirm by using --force twice.)
  /dev/sdb: physical volume label not removed.
[root@bogon ceshi]# vgreduce centos_bogon /dev/sdb
  Removed "/dev/sdb" from volume group "centos_bogon"
[root@bogon ceshi]# pvs
  PV         VG           Fmt  Attr PSize   PFree   
  /dev/sda2  centos_bogon lvm2 a--  <29.00g    4.00m
  /dev/sdb                lvm2 ---   30.00g   30.00g
  /dev/sdc   centos_bogon lvm2 a--  <30.00g 1020.00m
[root@bogon ceshi]# pvremove 
cehsi.txt   lost+found/ 
[root@bogon ceshi]# pvremove /dev/sdb
  Labels on physical volume "/dev/sdb" successfully wiped.
[root@bogon ceshi]# pvs
  PV         VG           Fmt  Attr PSize   PFree   
  /dev/sda2  centos_bogon lvm2 a--  <29.00g    4.00m
  /dev/sdc   centos_bogon lvm2 a--  <30.00g 1020.00m

```

 

查看确认正常 

```shell
[root@bogon ceshi]# df -TH
文件系统                       类型      容量  已用  可用 已用% 挂载点
/dev/mapper/centos_bogon-root  xfs        29G  1.2G   28G    4% /
devtmpfs                       devtmpfs  952M     0  952M    0% /dev
tmpfs                          tmpfs     964M     0  964M    0% /dev/shm
tmpfs                          tmpfs     964M  9.0M  955M    1% /run
tmpfs                          tmpfs     964M     0  964M    0% /sys/fs/cgroup
/dev/sda1                      xfs       1.1G  152M  912M   15% /boot
/dev/mapper/centos_bogon-ceshi ext4       31G   29M   30G    1% /ceshi
tmpfs                          tmpfs     193M     0  193M    0% /run/user/0
[root@bogon ceshi]# vgs 
  VG           #PV #LV #SN Attr   VSize  VFree
  centos_bogon   2   3   0 wz--n- 58.99g 1.00g
[root@bogon ceshi]# lvs
  LV    VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  ceshi centos_bogon -wi-ao---- 29.00g                                                    
  root  centos_bogon -wi-ao---- 26.99g                                                    
  swap  centos_bogon -wi-ao----  2.00g                                                    
```

注：

blkid 

使用blkid 查看已格式化分区的UUID和文件系统。使用blkid可以输出分区或分区的文件系统类型，查看TYPE字段输出。

```shell
[root@bogon ~]# blkid
/dev/sda1: UUID="286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80" TYPE="xfs" 
/dev/sda2: UUID="4LapEC-4R0M-Uf0c-dxEL-l7SX-my8y-hXjWVp" TYPE="LVM2_member" 
/dev/sdb: UUID="sIT7Db-ErGC-Wz4h-T5Vq-GoPF-nDqh-0fEEVC" TYPE="LVM2_member" 
/dev/mapper/centos_bogon-root: UUID="18992acd-5d01-4416-b371-f8034b81a88e" TYPE="xfs" 
/dev/mapper/centos_bogon-swap: UUID="04721e03-2370-40f4-a5c9-3f41e7b09709" TYPE="swap" 
/dev/mapper/centos_bogon-ceshi: UUID="f9146c4e-b43c-4539-8475-44b5021518f6" TYPE="ext4" 

```

parted -l命令查看

如下所示，parted -l 命令会输出文件系统类型（File system）， 其中参数l表示列出所有设备的分区信息。

```shell
[root@bogon ~]# parted -l
Model: ATA VBOX HARDDISK (scsi)
Disk /dev/sda: 32.2GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type     File system  标志
 1      1049kB  1075MB  1074MB  primary  xfs          启动
 2      1075MB  32.2GB  31.1GB  primary               lvm


错误: /dev/sdb: unrecognised disk label
Model: ATA VBOX HARDDISK (scsi)                                           
Disk /dev/sdb: 32.2GB
Sector size (logical/physical): 512B/512B
Partition Table: unknown
Disk Flags: 

Model: Linux device-mapper (linear) (dm)
Disk /dev/mapper/centos_bogon-ceshi: 31.1GB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system  标志
 1      0.00B  31.1GB  31.1GB  ext4


Model: Linux device-mapper (linear) (dm)
Disk /dev/mapper/centos_bogon-swap: 2147MB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system     标志
 1      0.00B  2147MB  2147MB  linux-swap(v1)


Model: Linux device-mapper (linear) (dm)
Disk /dev/mapper/centos_bogon-root: 29.0GB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system  标志
 1      0.00B  29.0GB  29.0GB  xfs

```



命令lsblk -f 查看

有些系统可能没有这个命令，需要安装。注意：lsblk -f也可以查看未挂载的文件系统类型

```shell
[root@bogon ~]# lsblk  -f
NAME                  FSTYPE      LABEL UUID                                   MOUNTPOINT
sda                                                                            
├─sda1                xfs               286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80   /boot
└─sda2                LVM2_member       4LapEC-4R0M-Uf0c-dxEL-l7SX-my8y-hXjWVp 
  ├─centos_bogon-root xfs               18992acd-5d01-4416-b371-f8034b81a88e   /
  └─centos_bogon-swap swap              04721e03-2370-40f4-a5c9-3f41e7b09709   [SWAP]
sdb                   LVM2_member       sIT7Db-ErGC-Wz4h-T5Vq-GoPF-nDqh-0fEEVC 
└─centos_bogon-ceshi  ext4              f9146c4e-b43c-4539-8475-44b5021518f6   /ceshi
sr0                                                                            

```



#### 3.Scp、Rsync远程同步文件传输类工具

​    远程之前先建立ssh 信任

```shell
rsync -av /opt/software/ hadoop102:/opt/software

# 本地文件 :文件.txt
scp -P 2222 文件.txt root@127.0.0.1:/root

```



#### 4.nginx 安装和使用

##### 1.编译安装nginx

Linux 安装软件nginx
一、	安装nginx
官方安装地址：https://unit.nginx.org/installation/
参考地址：https://www.cnblogs.com/herui1991/p/8996917.html

依赖：
1.依赖环境介绍
gcc gcc-c++
gcc为GNU Compiler Collection的缩写，可以编译C和C++源代码等，它是GNU开发的C和C++以及其他很多种语言 的编译器（最早的时候只能编译C，后来很快进化成一个编译多种语言的集合，如Fortran、Pascal、Objective-C、Java、Ada、 Go等。）
gcc 在编译C++源代码的阶段，只能编译 C++ 源文件，而不能自动和 C++ 程序使用的库链接（编译过程分为编译、链接两个阶段，注意不要和可执行文件这个概念搞混，相对可执行文件来说有三个重要的概念：编译（compile）、链接（link）、加载（load）。源程序文件被编译成目标文件，多个目标文件连同库被链接成一个最终的可执行文件，可执行文件被加载到内存中运行）。因此，通常使用 g++ 命令来完成 C++ 程序的编译和连接，该程序会自动调用 gcc 实现编译。
gcc-c++也能编译C源代码，只不过把会把它当成C++源代码，后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。
make automake
make是一个用来控制可执行文件和其他一些从源文件来的非源代码文件版本的软件。Make可以从一个名为makefile的文件中获得如何构建你所写程序的依赖关系，Makefile中列出了每个目标文件以及如何由其他文件来生成它。
automake是一个从Makefile.am文件自动生成Makefile.in的工具。为了生成Makefile.in，automake还需用到perl，由于automake创建的发布完全遵循GNU标准，所以在创建中不需要perl。libtool是一款方便生成各种程序库的工具。
autoconf
autoconf是用来生成自动配置软件源代码脚本（configure）的工具
pcre pcre-devel
在Nginx编译需要 PCRE(Perl Compatible Regular Expression)，因为Nginx 的Rewrite模块和HTTP 核心模块会使用到PCRE正则表达式语法。
zlip zlib-devel
nginx启用压缩功能的时候，需要此模块的支持。
openssl openssl-devel 
开启SSL的时候需要此模块的支持。
Libtool

libtool是一个通用库支持脚本，将使用动态库的复杂性隐藏在统一、可移植的接口中；使用libtool的标准方法，可以在不同平台上创建并调用动态库。
libtool主要的一个作用是在编译大型软件的过程中解决了库的依赖问题；将繁重的库依赖关系的维护工作承担下来，从而释放了程序员的人力资源。libtool提供统一的接口，隐藏了不同平台间库的名称的差异等细节，生成一个抽象的后缀名为la高层库libxx.la（其实是个文本文件），并将该库对其它库的依赖关系，都写在该la的文件中。

安装依赖包的命令：

yum -y install gcc gcc-c++ make automake autoconf pcre pcre-devel zlib zlib-devel openssl openssl-devel libtool

安装命令：

```shell
./configure  --prefix=/usr/local/nginx  --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --error-log-path=/var/log/nginx/error.log  --http-log-path=/var/log/nginx/access.log  --pid-path=/var/run/nginx/nginx.pid --lock-path=/var/lock/nginx.lock  --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=/var/tmp/nginx/client/ --http-proxy-temp-path=/var/tmp/nginx/proxy/ --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi --http-scgi-temp-path=/var/tmp/nginx/scgi --with-pcre --with-stream=dynamic
```

Make & make install 

启动、停止Nginx服务
[root@herui ~]# /usr/local/nginx/sbin/nginx   #启动Nginx
nginx: [emerg] getpwnam("nginx") failed   #没有Nginx用户
[root@herui ~]# /usr/local/nginx/sbin/nginx -s stop   #停止Nginx
[root@herui ~]# /usr/local/nginx/sbin/nginx -s reload    #不停止服务，重新加载配置文件
验证Nginx是否开启成功
[root@herui ~]# ps aux|grep nginx
root       2218  0.0  0.1  47320  1188 ?        Ss   10:21   0:00 nginx: master process /usr/local/nginx/sbin/nginx
nginx      2219  0.0  0.1  47756  1760 ?        S    10:21   0:00 nginx: worker process      
root       2222  0.0  0.0 103256   836 pts/0    S+   10:21   0:00 grep nginx

nginx注意事项：

You need it to be 'static' - so load the module directly. To do so, add the following at the very top of your nginx.conf:

```shell
#要想支持stream语法
load_module /usr/lib/nginx/modules/ngx_stream_module.so;
```

vim /usr/local/nginx/conf/nginx.conf
user nginx nginx;           # 指定Nginx服务的用户和用户组
一般来说，这个用户是需要自己建的。测试一般写root即可

```shell
nginx -s reload
service nginx restart
```

##### 2.编译安装 openssl linux

1、 去官网下载最新版本，或wget下载也行 http://www.openssl.org

1、 解压并进入解压目录后执行：

```
[root@bogon ~]# ./config --prefix=/usr/local/openssl 
```

2、 备份并替换：

```shell
[root@bogon ~]# mv /usr/local/openssl /usr/local/openssl.bak
[root@bogon ~]# make && make install
[root@bogon ~]# mv /usr/include/openssl /usr/include/openssl.bak

[root@bogon ~]# ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl
[root@bogon ~]# ln -s /usr/local/openssl/include/openssl /usr/include/openssl
# 更新动态链接库数据
[root@bogon ~]#  echo "/usr/local/openssl/lib" >> /etc/ld.so.conf
#重新加载动态链接库
ldconfig -v
#重新查看版本号：
[root@bogon ~]# openssl version –a


#如果在更新完后执行openssl version 命令报错
#这可能由于openssl库的位置不正确造成的。
#可以做一个软连接：
ln -s /usr/local/openssl/lib/libssl.so.1.1 /usr/lib/
ln -s /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib/
#参考地址：https://www.cnblogs.com/caibao666/p/9698842.html	
```





#### 5. 快捷操作

查看域里面有哪些用户

```shell
cat /etc/passwd |awk -F ':' '{ print $1":"$2":"$4":"$5":"$6 }' |grep 1001
```



批量杀死进程

```shell
ps -ef | grep test | grep -v grep | awk '{print $2}' | xargs kill -9
```



按照 文件大小 删除 列出前十条大文件

```shell
ls|grep log |xargs du -sm|sort -rn|head |awk '{print $2}'
```



### 三、Linux 常用设置

#### 1.  常见时间设置

##### 1. 常用时间设置

date命令

```shell
[root@bogon ~]# date  #查看时间
2020年 11月 23日 星期一 21:51:24 CST

[root@bogon ~]# date --help  #查看更多

[root@bogon ~]# date "+%Y_%m_%d  %H-%M-%S"  #格式化时间
2020_11_23  21-53-48

#设置date样式
[root@k8smaster01 ~]# export TIME_STYLE='+%Y/%m/%d %H:%M:%S'

```



Linux硬件时间的设置 hwclock或者clock命令

```shell
[root@bogon ~]# hwclock --show   #查看硬件时间
2020年11月23日 星期一 21时56分11秒  -0.577414 秒

[root@bogon ~]# hwclock -w  #以系统时间为基准，修改硬件时间

[root@bogon ~]# hwclock --hctosys  #以硬件时间为基准，修改系统时间

[root@bogon ~]# hwclock --help

用法：
 hwclock [功能] [选项...]

功能：
 -h, --help           显示此帮助并退出
 -r, --show           读取硬件时钟并打印结果
     --set            将 RTC 设置为 --date 指定的时间
 -s, --hctosys        从硬件时钟设置系统时间
 -w, --systohc        从当前系统时间设置硬件时钟
     --systz          基于当前时区设置系统时间
     --adjust         根据自上次时钟设置或调整后的系统漂移
                        来调整 RTC
 -c, --compare        定期将系统时钟与 CMOS 时钟相比较
     --getepoch       打印内核的硬件时钟纪元(epoch)值
     --setepoch       将内核的硬件时钟纪元(epoch)值设置为
                        --epoch 选项指定的值
     --predict        预测 --date 选项所指定时刻读取到的 RTC 值
 -V, --version        显示版本信息并退出

选项：
 -u, --utc            硬件时钟保持为 UTC 时间
     --localtime      硬件时钟保持为本地时间
 -f, --rtc <文件>     代替默认文件的特殊 /dev/... 文件
     --directisa      直接访问 ISA 总线，而非 /dev/rtc
     --badyear        忽略  RTC 年份(由于 BIOS 损坏)
     --date <时间>    指定要设置的硬件时钟时间
     --epoch <年>     指定作为硬件纪元(epoch)值起始的年份
     --noadjfile      不访问 /etc/adjtime；需要使用 --utc 或 --localtime 选项
     --adjfile <文件> 指定调整文件的路径；
                        默认为 /etc/adjtime
     --test           不更新，只显示将进行什么操作
 -D, --debug          调试模式

```



```shell
[root@bogon ~]# clock --help

用法：
 hwclock [功能] [选项...]

功能：
 -h, --help           显示此帮助并退出
 -r, --show           读取硬件时钟并打印结果
     --set            将 RTC 设置为 --date 指定的时间
 -s, --hctosys        从硬件时钟设置系统时间
 -w, --systohc        从当前系统时间设置硬件时钟
     --systz          基于当前时区设置系统时间
     --adjust         根据自上次时钟设置或调整后的系统漂移
                        来调整 RTC
 -c, --compare        定期将系统时钟与 CMOS 时钟相比较
     --getepoch       打印内核的硬件时钟纪元(epoch)值
     --setepoch       将内核的硬件时钟纪元(epoch)值设置为
                        --epoch 选项指定的值
     --predict        预测 --date 选项所指定时刻读取到的 RTC 值
 -V, --version        显示版本信息并退出

选项：
 -u, --utc            硬件时钟保持为 UTC 时间
     --localtime      硬件时钟保持为本地时间
 -f, --rtc <文件>     代替默认文件的特殊 /dev/... 文件
     --directisa      直接访问 ISA 总线，而非 /dev/rtc
     --badyear        忽略  RTC 年份(由于 BIOS 损坏)
     --date <时间>    指定要设置的硬件时钟时间
     --epoch <年>     指定作为硬件纪元(epoch)值起始的年份
     --noadjfile      不访问 /etc/adjtime；需要使用 --utc 或 --localtime 选项
     --adjfile <文件> 指定调整文件的路径；
                        默认为 /etc/adjtime
     --test           不更新，只显示将进行什么操作
 -D, --debug          调试模式

```



##### 2.  ntpd 时间同步工具

> ​		要注意的是，ntpd 有一个自我保护设置: <u>如果本机与上源时间相差太大, ntpd 不运行</u>. 所以新设置的时间服务器一定要先 ntpdate 从上源取得时间初值, 然后启动 ntpd服务。ntpd服务运行后, 先是每64秒与上源服务器同步一次, 根据每次同步时测得的误差值经复杂计算逐步调整自己的时间, 随着误差减小, 逐步增加同步的间隔. 每次跳动, 都会重复这个调整的过程。



安装命令：

```shell
[root@bogon ~]# yum install ntpdate ntp -y
```



​		**思路：使用ntpd服务，要好于ntpdate加cron的组合。因为，ntpdate同步时间，会造成时间的跳跃，对一些依赖时间的程序和服务会造成影响。比如sleep，timer等。而且，ntpd服务可以在修正时间的同时，修正cpu tick。理想的做法为，在开机的时候，使用ntpdate强制同步时间，在其他时候使用ntpd服务来同步时间。**



```shell
[root@bogon ~]# cat /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed

0 12 * * * * /usr/sbin/ntpdate 192.168.0.1  # 这样，会在每天的12点整，同步一次时间。ntp服务器为192.168.0.1。
```



**ntp服务端：**

ntpd服务的相关设置文件如下：

```
1. /etc/ntp.conf：这个是NTP daemon的主要设文件，也是 NTP 唯一的设定文件。

2. /usr /share/zoneinfo/:在这个目录下的文件其实是规定了各主要时区的时间设定文件，例如北京地区的时区设定文件在 /usr/share/zoneinfo/Asia/Beijing 就是了。这个目录里面的文件与底下要谈的两个文件(clock 与localtime)是有关系的。

3. /etc/sysconfig/clock：这个文件其实也不包含在NTP 的 daemon 当中，因为这个是 linux 的主要时区设定文件。每次开机后，Linux 会自动的读取这个文件来设定自己系统所默认要显示的时间。

4. /etc/localtime：这个文件就是“本地端的时间配置文件”。刚刚那个clock 文件里面规定了使用的时间设置文件(ZONE) 为 /usr/share/zoneinfo/Asia/Beijing ，所以说，这就是本地端的时间了，此时， Linux系统就会将Beijing那个文件另存为一份 /etc/localtime文件，所以未来我们的时间显示就会以Beijing那个时间设定文件为准。

5. /etc/timezone：系统时区文件
```



```shell
[root@linux ~]# vi /etc/ntp.conf 
# 1. 关于权限设定部分 
#　　 权限的设定主要以 restrict 这个参数来设定，主要的语法为： 
# 　　restrict IP mask netmask_IP parameter 
# 　　其中 IP 可以是软件地址，也可以是 default ，default 就类似 0.0.0.0 
#　　 至于 paramter 则有： 
#　　　ignore　：关闭所有的 NTP 联机服务 
#　　　nomodify：表示 Client 端不能更改 Server 端的时间参数，不过，

#　　　Client 端仍然可以透过 Server 端来进行网络校时。 
#　　　notrust ：该 Client 除非通过认证，否则该 Client 来源将被视为不信任网域 
#　　　noquery ：不提供 Client 端的时间查询

#　　　notrap ：不提供trap这个远程事件登入

#　　如果 paramter 完全没有设定，那就表示该 IP (或网域)“没有任何限制”

restrict default nomodify notrap noquery　# 关闭所有的 NTP 要求封包 
restrict 127.0.0.1　　　 #这是允许本级查询
restrict 192.168.0.1 mask 255.255.255.0 nomodify 
#在192.168.0.1/24网段内的服务器就可以通过这台NTP Server进行时间同步了 
# 2. 上层主机的设定 
#　　要设定上层主机主要以 server 这个参数来设定，语法为：
#　　server [IP|HOST Name] [prefer]
#　　Server 后面接的就是我们上层 Time Server 啰！而如果 Server 参数 
#　　后面加上 perfer 的话，那表示我们的 NTP 主机主要以该部主机来作为 
#　　时间校正的对应。另外，为了解决更新时间封包的传送延迟动作， 
#　　所以可以使用 driftfile 来规定我们的主机 
#　　在与 Time Server 沟通时所花费的时间，可以记录在 driftfile  
#　　后面接的文件内，例如下面的范例中，我们的 NTP server 与  
#　　cn.pool.ntp.org联机时所花费的时间会记录在 /etc/ntp/drift文件内 
server 0.pool.ntp.org

server 1.pool.ntp.org

server 2.pool.ntp.org

server cn.pool.ntp.org prefer

#其他设置值，以系统默认值即可

server  127.127.1.0     # local clock

fudge   127.127.1.0 stratum 10

driftfile /var/lib/ntp/drift
broadcastdelay  0.008
keys /etc/ntp/keys
```



总结一下，restrict用来设置访问权限，server用来设置上层时间服务器，driftfile用来设置保存漂移时间的文件。



 ntp服务的启动与观察

在启动NTP服务前，先对提供服务的这台主机手动的校正一次时间咯。（因为启动服务器，端口会被服务端占用，就不能手动同步时间了）

```shell
[root@linux ~] # ntpdate cn.pool.ntp.org

25 Apr 14:33:51 ntpdate[8310]: step time server 80.85.129.2 offset 6.655976 sec
```

然后，启动ntpd服务：

```shell
[root@linux ~] # service ntpd start
```

或

```shell
 [root@linux ~] # /etc/init.d/ntpd start
```

查看端口：

```shell
[root@bogon ~]# netstat -ln |grep 123
udp        0      0 192.168.1.109:123       0.0.0.0:*                          
udp        0      0 127.0.0.1:123           0.0.0.0:*                          
udp        0      0 0.0.0.0:123             0.0.0.0:*                          
udp6       0      0 fe80::dfa3:af17:f0c:123 :::*                               
udp6       0      0 ::1:123                 :::*                               
udp6       0      0 :::123                  :::*                   
```

常见的错误：

25 Apr 15:30:17 ntpdate[11520]: no server suitable for synchronization found

其实，这不是一个错误。而是由于每次重启NTP服务器之后大约要3－5分钟客户端才能与server建立正常的通讯连接。当此时用客户端连接服务端就会报这样的信息。一般等待几分钟就可以了。

 最后提及一点，ntp服务，默认只会同步系统时间。如果想要让ntp同时同步硬件时间，可以设置/etc/sysconfig/ntpd 文件。

在/etc/sysconfig/ntpd文件中，添加 SYNC_HWCLOCK=yes 这样，就可以让硬件时间与系统时间一起同步。



###### 注：测试工具ntpdc

```shell
ntpdc -np
```



#### 2. swap 虚拟内存设置



> ​		很久很久以前，电脑的内存是个珍贵东西，于是乎就有了swap这个东西，简单来说就是内存不够用的时候，用硬盘空间顶上。这个分区在近些年来已经越来越不受大家的待见了，主要是因为现在内存比较宽裕，但是在小内存的VPS上，还是有自己的用武之地的，特别是当看到内存不足之类的错误出现在log中的时候，可以尝试创建swap来分担一下内存的压力。
>
> ​		swap无法替代物理内存，性能上也会差很多，在SSD硬盘上使用对读写性能会有所加成。另外本文是通过创建一个swap文件来充当交换空间的作用，与Partition方法不同。



##### 一、 查看swap分区工具

```shell
[root@bogon ~]# free -m  
              total        used        free      shared  buff/cache   available
Mem:           1838         102        1577           8         158        1567
Swap:          2047           0        2047

```

查看swap分区列表

```shell
[root@bogon ~]# swapon -s
文件名				类型		大小	已用	权限
/dev/dm-1                              	partition	2097148	0	-2

```

swap 命令帮助

```shell
[root@bogon ~]# swapon --help

用法：
 swapon [选项] [<指定>]

选项：
 -a, --all                enable all swaps from /etc/fstab
 -d, --discard[=<policy>] enable swap discards, if supported by device
 -e, --ifexists           silently skip devices that do not exist
 -f, --fixpgsz            reinitialize the swap space if necessary
 -p, --priority <prio>    specify the priority of the swap device
 -s, --summary            display summary about used swap devices
     --show[=<columns>]   display summary in definable table
     --noheadings         don't print headings, use with --show
     --raw                use the raw output format, use with --show
     --bytes              display swap size in bytes in --show output
 -v, --verbose            verbose mode

 -h, --help     显示此帮助并退出
 -V, --version  输出版本信息并退出

<spec> 参数：
 -L <标签>              同 LABEL=<标签>
 -U <uuid>              同 UUID=<uuid>
 LABEL=<标签>           按交换区标签指定设备
 UUID=<uuid>            按交换区 UUID 指定设备
 PARTLABEL=<标签>       按分区标签指定设备
 PARTUUID=<uuid>        按分区 UUID 指定设备
 <设备>                 要使用设备的名称
 <文件>                 要使用文件的名称

Available discard policy types (for --discard):
 once	  : only single-time area discards are issued. (swapon)
 pages	  : discard freed pages before they are reused.
 * if no policy is selected both discard types are enabled. (default)

可用列(用于 --show)：
 NAME  设备文件或分区路径
 TYPE  设备的类型
 SIZE  交换区大小
 USED  已使用字节数
 PRIO  交换优先级

更多信息请参阅 swapon(8)。

```



```shell
[root@bogon ~]# swapoff --help

用法：
 swapoff [选项] [<指定>]

选项：
 -a, --all              禁用 /proc/swaps 中的所有交换区
 -v, --verbose          verbose mode

 -h, --help     显示此帮助并退出
 -V, --version  输出版本信息并退出

 <指定> 参数包括：
 -L <标签>              要使用设备的标签
 -U <uuid>              要使用设备的 UUID
 LABEL=<标签>           要使用设备的标签
 UUID=<uuid>            要使用设备的 UUID
 <设备>                 要使用设备的名称
 <文件>                 要使用文件的名称

更多信息请参阅 swapoff(8)。

```



##### 二、创建分区并创建swap分区

​		这里使用lvm做分区示例，因为swap一般做应急或其他特殊用途，在选用方式上 使用单独的标准裸分区也许更高效，但一般没有这个必要。lvm请在本书内容里查找.

创建独立的lvm分区：

```shell
[root@bogon ~]# pvcreate /dev/sdb
  Physical volume "/dev/sdb" successfully created.
[root@bogon ~]# vgs
  VG           #PV #LV #SN Attr   VSize  VFree
  centos_bogon   2   3   0 wz--n- 58.99g 1.00g
[root@bogon ~]# vgextend centos_bogon /dev/sdb
  Volume group "centos_bogon" successfully extended
[root@bogon ~]# lvs
  LV    VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  ceshi centos_bogon -wi-ao---- 29.00g                                                    
  root  centos_bogon -wi-ao---- 26.99g                                                    
  swap  centos_bogon -wi-ao----  2.00g                                                    
[root@bogon ~]# vgs
  VG           #PV #LV #SN Attr   VSize   VFree 
  centos_bogon   3   3   0 wz--n- <63.99g <6.00g
[root@bogon ~]# lvcreate -n swap_ceshi -L 5G centos_bogon
  Logical volume "swap_ceshi" created.
[root@bogon ~]# lvs
  LV         VG           Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  ceshi      centos_bogon -wi-ao---- 29.00g                                                    
  root       centos_bogon -wi-ao---- 26.99g                                                    
  swap       centos_bogon -wi-ao----  2.00g                                                    
  swap_ceshi centos_bogon -wi-a-----  5.00g                                                    
```

创建swap分区文件：

```shell
[root@bogon ~]# ls /dev/mapper/centos_bogon-swap_ceshi 
/dev/mapper/centos_bogon-swap_ceshi
[root@bogon ~]# dd if=/dev/zero of=/dev/mapper/centos_bogon-swap_ceshi bs=1M count=2048  #dd可以做很多事 可以参见本书查看详情
记录了2048+0 的读入
记录了2048+0 的写出
2147483648字节(2.1 GB)已复制，5.37086 秒，400 MB/秒

[root@bogon ~]# mkswap --help

用法
 mkswap [选项] 设备 [大小]

选项：
 -c, --check               创建交换区前检查坏块
 -f, --force               允许交换区大于设备大小
 -p, --pagesize SIZE       指定页大小为 SIZE 字节
 -L, --label LABEL         指定标签为 LABEL
 -v, --swapversion NUM     指定交换空间版本号为 NUM
 -U, --uuid UUID           指定要使用的 UUID
 -V, --version             输出版本信息并退出
 -h, --help                显示此帮助并退出

[root@bogon ~]# mkswap /dev/mapper/centos_bogon-swap_ceshi
正在设置交换空间版本 1，大小 = 5242876 KiB
无标签，UUID=6d2edf85-9c80-47de-ac82-248e4887a748


```



##### 三、启用swap分区并删除多余的swap分区

启用

```shell
[root@bogon ~]# swapon /dev/mapper/centos_bogon-swap_ceshi
[root@bogon ~]# swapon -s
文件名				类型		大小	已用	权限
/dev/dm-1                              	partition	2097148	0	-2
/dev/dm-3                              	partition	5242876	0	-3

```

禁用

```shell
[root@bogon ~]# swapoff /dev/dm-1 
[root@bogon ~]# swapon -s
文件名				类型		大小	已用	权限
/dev/dm-3                              	partition	5242876	0	-2

```



添加开机自动挂载并删除以前挂载swap文件

原:

```
[root@bogon ~]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Fri Nov 20 10:54:05 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos_bogon-root /                       xfs     defaults        0 0
UUID=286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80 /boot                   xfs     defaults        0 0
/dev/mapper/centos_bogon-swap swap                    swap    defaults        0 0
/dev/mapper/centos_bogon-ceshi    /ceshi              ext4    defaults        0 0

```



修改为

```shell
[root@bogon ~]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Fri Nov 20 10:54:05 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos_bogon-root /                       xfs     defaults        0 0
UUID=286b7fad-cc40-4a6f-9c55-4d9c3e5e1a80 /boot                   xfs     defaults        0 0
/dev/mapper/centos_bogon-ceshi    /ceshi              ext4    defaults        0 0
/dev/mapper/centos_bogon-swap_ceshi   swap             swap    defaults        0 0

[root@bogon ~]# mount -a
```



注：有的机器为了性能的原因不允许使用swap分区，因为这可能导致io性能下降. 如果在 /etc/rc.local 中有 swapoff -a 需要修改为 swapon -a



##### 四、其他设置

**修改 swpapiness 参数**
		在 Linux 系统中，可以通过查看 /proc/sys/vm/swappiness 内容的值来确定系统对 SWAP 分区的使用原则。当 swappiness 内容的值为 0 时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 SWAP 分区。当 swappiness 内容的值为 100 时，表示积极地使用 SWAP 分区，并且把内存中的数据及时地置换到 SWAP 分区。

```shell
[root@bogon ~]# cat  /proc/sys/vm/swappiness
30
```

查看修改前为 0，需要在物理内存使用完毕后才会使用 SWAP 分区。
可以使用下述方法临时修改此参数，假设我们配置为空闲内存少于 10% 时才使用 SWAP 分区：

```shell
echo 10 > /proc/sys/vm/swappiness
```

若需要永久修改此配置，在系统重启之后也生效的话，可以修改 /etc/sysctl.conf 文件，并增加以下内容：

```shell
[root@bogon ~]# cat /etc/sysctl.conf 
vm.swappiness=10

[root@bogon ~]# sysctl -p
```

若需要永久修改此配置，在系统重启之后也生效的话，可以修改 /etc/sysctl.conf 文件，并增加以下内容：
vm.swappiness=10

**关闭swap**

当系统出现内存不足时，开启 SWAP 可能会因频繁换页操作，导致 IO 性能下降。如果要关闭 SWAP，可以采用如下方法。



1. 使用命令swapoff 关闭 SWAP，比如：swapoff /mnt/swap

```shell
swapoff /mnt/swap
```

2. 修改 /etc/fstab 文件，删除或注释相关配置，取消 SWAP 的自动挂载：

3. swappiness 参数调整：
   可以使用下述方法临时修改此参数，这里配置为 0%：

```shell
echo 0 > /proc/sys/vm/swappiness
```

4. 若需要永久修改此配置，在系统重启之后也生效的话，可以修改 /etc/sysctl.conf文件，并增加以下内容：

```shell
[root@bogon ~]# cat /etc/sysctl.conf 
vm.swappiness=0
[root@bogon ~]# sysctl -p
```



#### 3. 开机自启动服务等

对于Centos来说：

1. 最简单的方式就是

```shell
[root@k8smaster01 ~]# ls /etc/rc.local 
/etc/rc.local
#给 rc.local 赋予执行的权限
[root@k8smaster01 ~]# chmod +x /etc/rc.local 
```

2. 其他

#### 4. 安全类问题selinux、防火墙、iptables等

##### 1. 设置selinux开机自动关闭

我们可以使用setenforce 命令设置临时关闭，不用重启生效。

```shell
[root@k8smaster01 ~]# setenforce 0
setenforce: SELinux is disabled

#手动编写SELINUX=disabled 来关闭
[root@k8smaster01 ~]# cat /etc/selinux/config 
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected. 
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted 

```



##### 4.filewalld 等防火墙 简介和使用

1.Filewalld 简介和使用

```shell
添加一条富规则
firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address=" 112.86.225.56" port protocol="tcp" port="443" accept"

删除一条富规则
firewall-cmd --permanent --remove-rich-rule="rule family="ipv4" source address=" 112.80.131.49" port port="443" protocol="tcp" accept"

#删除所有的富规则
firewall-cmd --list-rich-rules|xargs -I {} firewall-cmd --permanent --remove-rich-rule="{}"

查看所有的规则
firewall-cmd --list-all-zones

查看富规则
firewall-cmd --list-rich-rules
#重载
firewall-cmd --reload

```



2.iptables 简介和使用

参考地址：

教程
https://www.bilibili.com/video/BV1XZ4y1s7mU?p=4&spm_id_from=pageDriver
英文教程
https://wiki.archlinux.org/title/Iptables#Configuration_and_usage
手册
https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TABLE.SNATTARGET



```shell
默认都为filter

禁止端口
iptables -I INPUT -p tcp --dport 443 -j DROP
iptables -I INPUT -p udp --dport 443 -j DROP


##向后添加一条数据

iptables -I INPUT -s  153.3.90.185 -p tcp --dport 443 -j ACCEPT
iptables -I INPUT -s  153.3.90.185  -p udp --dport 443 -j ACCEPT

##查看默认filter条数
iptables -t filter -nL --line-number


```



例题一

需求 在192.168.113 上 访问 192.168.1.19 转发到  192.168.1.112 但是 192.168.113 不能访问 192.168.1.112  但是 192.168.113可以访问 192.168.1.114 ，而 192.168.1.114 可以访问 192.168.1.112 
问 如果 在不影响 192.168.1.114 上端口的基础上 完成转发。

解答：本地直接访问不需要经过转发的链。+

```
iptables -t nat -A OUTPUT -d 192.168.1.19 -j DNAT --to-destination  192.168.1.114
```

正确

```
iptables -t nat -A PREROUTING -s 192.168.1.113  -d  192.168.1.114  -j DNAT --to-destination  192.168.1.112

iptables -t nat -A POSTROUTING  -d 192.168.1.112 -s 192.168.1.113   -j SNAT --to-source 192.168.1.114
```


解释 。 根据实验所得 192.168.1.114 主机会记住来往的数据 所以 第二条 -s 发送源应该是 192.168.1.113 而不是 114 自己。大致的意思就是 114 接收到了 113 上发的数据包 ，在114 的操作生命周期范围内 这个 113 的信息都被包含了。











3.redhat防火墙iptables设置

​    关于redhat6.8防火墙 iptables设置适用于大部分Centos、redhat系列

​	首先是配置文件在

​    /etc/sysconfig/iptables

这里是允许所有连接

```shell
iptables -P INPUT ACCEPT

iptables -P OUTPUT ACCEPT

iptables -P FORWARD ACCEPT

iptables -A INPUT -p tcp --dport 80 -j DROP

iptables -A INPUT -p udp --dport 80 -j DROP

iptables -A OUTPUT -p tcp --dport 80 -j DROP

iptables -A OUTPUT -p udp --dport 80 -j DROP

iptables -A FORWARD -p tcp --dport 80 -j DROP

iptables -A FORWARD -p udp --dport 80 -j DROP

iptables -L -n

保存配置文件

/etc/init.d/iptables save

或者service iptables save

 
```

##### 3. ssh无密钥配置

（1）免密登录原理，如图2-40所示

​	

![image-20210209000457938](.\images\image-20210209000457938.png)



（2）生成公钥和私钥：

```shell
[root@k8smaster01 ~]# ssh-keygen -t rsa
#然后敲（三个回车），就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
```

（3）将公钥拷贝到要免密登录的目标机器上

```shell
[root@k8smaster01 ~]# ssh-copy-id hadoop102
[root@k8smaster01 ~]# ssh-copy-id hadoop103
[root@k8smaster01 ~]# ssh-copy-id hadoop104
```





#### 5. 磁盘挂载、共享等问题。

##### 1. 挂载共享文件windows 共享给linux

```shell
mount -t cifs -o username=frank,password=xiaojian5791041,vers=2.0,dir_mode=0777,file_mode=0777  //192.168.1.105/linux_sys /mnt/windows
```



##### 2. 挂载光盘iso映像

```shell
mount -t iso9660 -o,loop /root/rhel-server-6.8-x86_64-dvd.iso /mnt
```



#### 6. 网络设置等

##### 1.基本网络地址设置

对于Centos、redhat 绝大多数 linux 系统 网络设置的路径为:

```shell
[root@k8smaster01 ~]# cd /etc/sysconfig/network-scripts/
[root@k8smaster01 network-scripts]# pwd
/etc/sysconfig/network-scripts
[root@k8smaster01 network-scripts]# ls
ifcfg-enp0s3  ifdown-ib    ifdown-ppp       ifdown-tunnel  ifup-ib    ifup-plusb   ifup-Team         network-functions
ifcfg-lo      ifdown-ippp  ifdown-routes    ifup           ifup-ippp  ifup-post    ifup-TeamPort     network-functions-ipv6
ifdown        ifdown-ipv6  ifdown-sit       ifup-aliases   ifup-ipv6  ifup-ppp     ifup-tunnel
ifdown-bnep   ifdown-isdn  ifdown-Team      ifup-bnep      ifup-isdn  ifup-routes  ifup-wireless
ifdown-eth    ifdown-post  ifdown-TeamPort  ifup-eth       ifup-plip  ifup-sit     init.ipv6-global
[root@k8smaster01 network-scripts]# pwd
/etc/sysconfig/network-scripts

#查看网络设置
[root@k8smaster01 network-scripts]# cat ifcfg-enp0s3 
TYPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
# BOOTPROTO 可以设置为 dhcp BOOTPROTO接受3个参数：none（禁止dhcp），static(静态IP)，dhcp（自动获取）
BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="enp0s3"
UUID="fd2600ad-fa32-4a4f-883e-62366b067c12"
DEVICE="enp0s3"
#是否开机自启
ONBOOT="yes"
#ip地址等设置
IPADDR=192.168.1.120
NETMASK=255.255.255.0
GATEWAY=192.168.1.106
DNS1=192.168.1.106

#修改完重启生效
[root@k8smaster01 network-scripts]# service network restart

```





#### 7. 环境变量设置、以及常见的环境变量作用

1.系统环境变量设置

```shell
#在/etc/profile文件后面添加环境变量
[root@k8smaster01 etc]# vim  /etc/profile
#例子
export PATH="$PATH:/opt/au1200_rm/build_tools/bin" 

#设置需要刷新环境变量即可得到环境变量值
[root@k8smaster01 etc]# source /etc/profile

[root@k8smaster01 etc]# echo $PATH

#path路径越靠前，优先级越高，而不是覆盖，排在后面优先级最低.

```



#### 8. linux用户权限等

##### 1. sudo设置方法

```shell
root@k8smaster01 yum.repos.d]# cat /etc/sudoers
#其中有这么一段
## Allow root to run any commands anywhere 
root	ALL=(ALL) 	ALL
#例子
oracle  ALL=(ALL) 	ALL
```





#### 9. 优化操作

##### 1. 手动清除缓存内存 

```shell
echo 3 > /proc/sys/vm/drop_caches
```



##### 2. 自建服务

修改service文件后需要重新加载service 

```shell
systemctl daemon-reload
```



#### 10.审计操作

##### 1.查看历史上机，下机记录

查看关机

```shell
[root@k8smaster01 yum.repos.d]# last
root     pts/0        192.168.1.44     Mon Feb  8 23:13   still logged in   
reboot   system boot  3.10.0-1160.15.2 Mon Feb  8 23:13 - 00:33  (01:20)    
root     pts/0        192.168.1.44     Sun Feb  7 22:27 - crash (1+00:46)   
root     tty1                          Sun Feb  7 22:26 - 00:00  (01:33)    
reboot   system boot  3.10.0-1160.15.2 Sun Feb  7 22:26 - 00:33 (1+02:07)   
root     pts/0        192.168.1.44     Thu Feb  4 10:43 - down   (14:34)    
reboot   system boot  3.10.0-957.el7.x Thu Feb  4 10:42 - 01:17  (14:34)    
root     pts/0        192.168.1.44     Thu Feb  4 10:35 - crash  (00:07)    
reboot   system boot  5.4.95-1.el7.elr Thu Feb  4 10:34 - 01:17  (14:43)    
root     pts/0        192.168.1.44     Thu Feb  4 10:07 - down   (00:26)    
reboot   system boot  3.10.0-957.el7.x Thu Feb  4 10:05 - 10:33  (00:27)    
root     tty1                          Thu Feb  4 09:57 - 09:57  (00:00)    
root     tty1                          Thu Feb  4 09:51 - 09:57  (00:05)    
reboot   system boot  3.10.0-957.el7.x Thu Feb  4 09:51 - 10:33  (00:42)    
root     tty1                          Thu Feb  4 09:34 - 09:34  (00:00)    
reboot   system boot  3.10.0-957.el7.x Thu Feb  4 09:33 - 10:33  (00:59)    

```

##### 2. 常用系统日志资源查看



```shell
/var/log/secure  登录日志

/var/log/secure   登录日志
who /var/log/wtmp 历史登录日志
w 登录时间 登录
last -f /var/log/wtmp
查看系统内核版本
cat /proc/version


查看发行版本
cat /etc/redhat-release

cat /etc/issue

查看是多少位

getconf LONG_BIT

查看基本信息

查看cpu是几核的
cat /proc/cpuinfo
查看内存信息
cat /proc/meminfo

查看路由网关

route -n

Uptime 用户的连接数,运行的时间

内存查看 free -bm

查看磁盘的使用情况
 Df -h 直观的方式查看
Df -T  类型

查看文件或目录所占用的空间
Du -sh
查看最近登录的用户
 Lastlo
查看这些用户是从哪个ip地址登录的
 Who
查看登录信息
 who /var/log/wtmp
查看端口信息


```





**日** **志** **文** **件**  **说**  **明** 

**/var/log/message** **系统启动后的信息和错误日志，是****Red Hat Linux****中最常用的日志之一** 

**/var/log/secure**   **与安全相关的日志信息** 

**/var/log/maillog**  **与邮件相关的日志信息** 

**/var/log/cron** **与定时任务相关的日志信息** 

**/var/log/spooler**  **与****UUCP****和****news****设备相关的日志信息** 

**/var/log/boot.log 守护进程启动和停止相关的日志消息** 





#### 11.关于linux动态库 动态加载库

vi /etc/ld.so.conf

/sbin/ldconfig -v

命令 /sbin/ldconf -v | grep "libaivse000" 查看是否系统有加载该库

查看动态库的地址

ldconfig -p

LD_LIBRARY_PATH 连接变量 = 需要加载.so的地址

export LD_LIBRARY_PATH=/opt/python/lib

然后重新加载 需要注意的时随意添加动态链接库可能会导致开机慢死机等。。。

#### 12. Linux常用的拓展库

```shell
yum -y install epel-release
```



#### 13. Linux设置文件权限

chown -R 用户名:用户所在的组 文件或目录

chmod -R ugo=rwx 文件或目录

ugo 表示为 用户 组  其他用户

chmod ug=wrx,o=wrx xiaojian.zip







### 四、linux 遇到的疑难杂症

#### 1. 已经杀死程序了，但无法启动程序，提示端口被绑定

> 参考链接：https://community.cloudera.com/t5/Support-Questions/Kafka-Socket-server-failed-Bind-Exception/td-p/243339

上面的链接为kafka解决的链接，以此为例场景如下：

1. 已经关闭kafka了，杀掉了程序，但还是无法启动kafka 提示：Socket server failed to bind to 0.0.0.0:9092: Address already in use.
2. 本机有许多的程序发起的长连接 链接kafka，kafka是突然掉线的，其他程序卡死，等待kafka的回应。
3. 是因为突然被删掉了本地文件导致的kafka突然离线。

猜测原因：可能本地的java socket 连接kafka 遇到kafka突然离线，并没有失去连接，而是等待返回连接，可能也没有设置什么超时。导致的socket一直占用kafka的端口通讯.

解决办法：

```shell
 lsof -n -i :9092 | grep LISTEN  #查看 与9092端口通讯的程序进程
```

上面代码会显示 与9092端口通讯的进程，强制杀掉他们，然后重启这些服务即可。











#### 2. plsql命令行导入文件总是乱码？

使用plsql的功能:文件->新建->命令行窗口。

导入文件时总是显示乱码，其实这和环境变量NLS_LANG有关

当你的导入文件时gbk编码时 应把NLS_LANG设置为对应的编码。猜测并测试其实是plsql以这个编码读取本地文件，然后使用数据库编码进行上传，

常见的编码设置如下:

SIMPLIFIED CHINESE_CHINA.ZHS16GBK

SIMPLIFIED CHINESE_CHINA.AL32UTF8

建议方法，把导入的文件手动的设置为何数据的编码一致，然后设置nls_lang为数据库编码，然后导入即可。

查看方法：帮助->支持信息



#### 3.账号密码都对，网络也没有限制，但怎么都登录不了Linux

正常情况下/var/log/tallylog权限：

```shell
[root@xuehen~]# ls  -ald  /var/log/tallylog
-rw- - - - - - -.  1  root   root  23808 Nov 20 13:28   /var/log/tallylog


#当权限为非此权限如下：
[root@xuehen~]# ls  -ald  /var/log/tallylog
-rwxrwxrwx. 1     root   root   23808 Nov 20 13:30   /var/log/tallylog

#报错如下
pam_tally2:/var/log/tallylog is  either world  wtitable or  not a normal file
pam_tally2:Authentication  error

#物理登录设置权限
[root@xuehen~]#
chmod  600   /var/log/tallylog

```



### 五、详解

#### 1.Linux开机过程

开机过程开机会先启动etc下目录的service文件 ，所有systemctl enable 实际上是复制一个快捷方式到etc目录下

/usr/lib/systemd/system

开启这个文件夹的

/usr/lib/systemd/system/multi-user.target.wants/

/etc/systemd/system

/etc/rc.d/init.d/

 



## k8s& Docker &docker Swarm 笔记





yum install bridge-utils  -y

http://blog.champbay.com/2019/04/28/lsmod%EF%BC%8Cmodprobe%E5%92%8Csysctl%E7%9A%84%E8%AF%B4%E6%98%8E/

modprobe br_netfilter #加载目标模块





